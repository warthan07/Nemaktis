#include <fstream>
#include <regex>

#include "LinearInterpolatedMapping.h"
#include "json.h"

template <int dim1, int dim2, typename T>
LinearInterpolatedMapping<dim1,dim2,T>::LinearInterpolatedMapping(
		const std::shared_ptr<std::vector<Vector<dim2,T> > > &values,
		const std::shared_ptr<CartesianMesh<dim1> > &mesh,
		const std::shared_ptr<DefinitionDomain<dim1> > &def_domain) :
	InterpolatedMapping<dim1,dim2,T>::InterpolatedMapping(
		values, mesh, def_domain, 2) {}

template<int dim1, int dim2, typename T>
std::shared_ptr<Mapping<dim1,dim2,T> > 
LinearInterpolatedMapping<dim1,dim2,T>::clone() const {
	return std::make_shared<LinearInterpolatedMapping<dim1,dim2,T> >(*this);
}

template<int dim1, int dim2, typename T>
void LinearInterpolatedMapping<dim1,dim2,T>::assemble_pol_weights(
		MultiDimIndex<dim1> &cell_origin_indices) {

	auto &v = this->v;
	auto &pol_coefs = this->pol_coefs;

	MultiDimIndex<dim1> cell_idx(2);
	for(; cell_idx.valid(); ++cell_idx) {
		v[cell_idx()] = (*this->values)[cell_origin_indices(cell_idx)];
	}

	// The following code was symbolically generated by Mathematica to
	// avoid mistakes.
	if(dim1==1) {
		pol_coefs[0] = v[0];
		pol_coefs[1] = -v[0] + v[1];
	}
	else if(dim1==2) {
		pol_coefs[0] = v[0];
		pol_coefs[1] = -v[0] + v[1];
		pol_coefs[2] = -v[0] + v[2];
		pol_coefs[3] = v[0] - v[1] - v[2] + v[3];
	}
	else if(dim1==3) {
		pol_coefs[0] = v[0];
		pol_coefs[1] = -v[0] + v[1];
		pol_coefs[2] = -v[0] + v[2];
		pol_coefs[3] = v[0] - v[1] - v[2] + v[3];
		pol_coefs[4] = -v[0] + v[4];
		pol_coefs[5] = v[0] - v[1] - v[4] + v[5];
		pol_coefs[6] = v[0] - v[2] - v[4] + v[6];
		pol_coefs[7] = -v[0] + v[1] + v[2] - v[3] + v[4] - v[5] - v[6] + v[7];
	}
}

template class LinearInterpolatedMapping<1,1,double>;
template class LinearInterpolatedMapping<1,2,double>;
template class LinearInterpolatedMapping<1,3,double>;
template class LinearInterpolatedMapping<2,1,double>;
template class LinearInterpolatedMapping<2,2,double>;
template class LinearInterpolatedMapping<2,3,double>;
template class LinearInterpolatedMapping<3,1,double>;
template class LinearInterpolatedMapping<3,2,double>;
template class LinearInterpolatedMapping<3,3,double>;

template class LinearInterpolatedMapping<1,1,std::complex<double> >;
template class LinearInterpolatedMapping<1,2,std::complex<double> >;
template class LinearInterpolatedMapping<1,3,std::complex<double> >;
template class LinearInterpolatedMapping<2,1,std::complex<double> >;
template class LinearInterpolatedMapping<2,2,std::complex<double> >;
template class LinearInterpolatedMapping<2,3,std::complex<double> >;
template class LinearInterpolatedMapping<3,1,std::complex<double> >;
template class LinearInterpolatedMapping<3,2,std::complex<double> >;
template class LinearInterpolatedMapping<3,3,std::complex<double> >;
